16BL ASM
16BL ASM IS A HIGH LEVEL ASSEMBLY LANGUAGE DESIGNED SPECIFICALLY FOR DESIGNING STRANGE GAMES. THE FULL INSTRUCTION SET, AS WELL AS A SMALL TUTORIAL, CAN BE FOUND ON THIS DOCUMENT.
________________


TUTORIAL
CHAPTER 1: WHAT YOU NEED TO KNOW
THE FIRST THING YOU NEED TO KNOW IS HOW THE GAME ENGINE WORKS. FIRST, THERE ARE SEVERAL DIFFERENT TYPES OF FILES, AND YOU NEED TO KNOW WHAT THEY ALL ARE. THE FIRST TYPE OF FILE IS THE "MAIN" FILE. THIS FILE INCLUDES THE CODE THAT GETS EXECUTED. FROM THE MAIN FILE, YOU CAN EXECUTE OTHER FILES CONTAINING CODE, CALLED SCRIPTS. EACH SCRIPT CAN BE 64 KB LONG, AND THE SAME GOES FOR THE "MAIN" FILE. WHEN A SCRIPT IS DONE EXECUTING, THE GAME ENGINE RETURNS TO THE "MAIN" FILE AND CONTINUES WHERE IT LEFT OFF. THE ENTIRETY OF THE CODE IS IN A LOOP, AND THE SCREEN IS UPDATED EVERY TIME THE LOOP FINISHES. THE SECOND TYPE OF FILE IS A SPRITE FILE. THERE IS A TOTAL OF 2 MB OF SPRITE STORAGE SPACE, AND WHILE IT IS POSSIBLE TO USE SCRIPTS TO ADD MORE, IT CAN BE VERY DIFFICULT AND SLOWS THE GAME DOWN SIGNIFICANTLY. THERE ARE 4 TYPES OF SPRITES: BINARY ( BLACK AND CLEAR, NOT GRAYSCALE ), 4 BIT ( 16 SET COLORS, THEY WILL BE LISTED BELOW (DEPRECATED)), NES ( 3 COLORS PER 8 X 8 PIXElS (DEPRECATED)), AND MASTER PALETTE ( 16 DEFINABLE COLORS ). BINARY SPRITES HAVE TO BE ADDRESSED DIFFERENTLY THAN THE OTHER FORMATS, BECAUSE BINARY SPRITES TAKE UP 8 BYTES AND OTHER FORMATS TAKE UP 32 BYTES. THE LAST TYPE OF FILE IS SOUND FILES WHICH CONTAIN THE MUSIC FOR THE GAME. THE ENGINE USES ALL OF THESE DIFFERENT FILES TO CREATE A GAME.
CHAPTER 2: OPCODES AND ARGUMENTS
THE 16BLASM INSTRUCTION SET CONSISTS OF 2 PARTS OF THE INSTRUCTION. THE FIRST PIECE, THE OPCODE, IS THE ID FOR THE INSTRUCTION. IT CONSISTS OF 2 PARTS: THE INSTRUCTION ID AND THE FLAGS. THE 5 BIT INSTRUCTION ID TELLS THE ENGINE WHAT THE OPCODE IS, AND THE FLAGS TELL IT SOME EXTRA INFORMATION ABOUT THE OPCODE. A COMPLETE LIST OF OPCODE IDS CAN BE FOUND AT THE BOTTOM OF THE DOCUMENT. THE THREE FLAGS ARE THE RELATIVE FLAG, WHICH ACTIVATES RELATIVE ADDRESSING ( LOADS THE VALUE FROM MEMORY INSTEAD OF A CONSTANT VALUE SUCH AS 5 ), THE RELATIVEX FLAG ( WHICH ADDS THE X REGISTER TO THE FIRST ARGUMENT BEFORE OTHER FLAGS ARE APPLIED ), AND THE NEGATIVE FLAG ( WHICH ACTIVATES RELATIVE-NEGATIVE BRANCHING ). THERE IS ACTUALLY A FOURTH FLAG CALLED THE BINARYSPRITE FLAG, AND IT ONLY WORKS TO LSP TO DECLARE THAT YOU’RE LOADING BINARY SPRITES. IT OCCUPIES THE SAME FLAG SLOT AS THE NEGATIVE FLAG. THE SECOND PART OF THE INSTRUCTION IS THE ARGUMENTS, WHICH DEFINE THE CONTEXT THAT THE FUNCTION IS USING ( IN THE CODE "ADD 5", ADD IS THE OPCODE AND 5 IS THE ARGUMENT. IN THIS EXAMPLE, THE FLAGS ARE NOT PRESENT ). ALSO, ALL NUMERIC ARGUMENTS ARE IN HEXADECIMAL. HERE IS A TABLE OF FLAGS:
$ - ACTIVATES RELATIVE ADDRESSING
~ - ACTIVATES RELATIVE BRANCHING
x - THE RELATIVEX FLAG
- - THE NEGATIVE FLAG
b - ACTIVATES THE BINARYSPRITE FLAG
FOR EXAMPLE, CONSIDER THE FOLLOWING CODE:
LDA 0005 // LOADS THE ACCUMULATOR TO 0005
STA 0000 // STORES THE ACCUMULATOR TO MEMORY AT ADDRESS 0000
ADD 0001 // ADDS 1 TO THE ACCUMULATOR
LDA $0001 // LOADS THE ACCUMULATOR TO THE VALUE STORED AT 0000
ADD $0001 // ADDS THE VALUE STORED AT ADDRESS 0000 TO THE ACCUMULATOR
STA 0000 // STORES THE VALUE IN THE ACCUMULATOR TO THE ADDRESS 0000
END // ENDS THE PROGRAM
THE END RESULT IS THE VALUE OF 10 BEING STORED IN THE ADDRESS 0000.




CHAPTER 3: YOUR FIRST PROGRAM
THE FIRST THING YOU NEED TO LEARN BEFORE WRITING A PROGRAM IS HOW TO COMMENT. TO ADD A COMMENT, USE //. ANYTHING AFTER THE // SYMBOL UNTIL THE END OF THE LINE IS CONSIDERED A COMMENT AND NOT READ BY THE COMPILER. FOR EXAMPLE:
// THIS LINE OF CODE DOES NOTHING
// THIS PROGRAM DOES NOTHING BECAUSE IT’S ALL COMMENTS
LDA 0001
// NEVER MIND, THERE’S AN INSTRUCTION BACK THERE
// THIS IS THE END OF THE PROGRAM
END // WOOHOO! I’M AFTER THE END OF THE PROGRAM!
NOW, YOU WILL LEARN HOW TO MAKE YOUR FIRST PROGRAM. YOU NEED TO USE 2 FUNCTIONS FOR THIS PROGRAM: LSP AND DSP. LSP LOADS A SPRITE INTO MEMORY WHILE DSP DRAWS IT. HERE IS THE EXAMPLE PROGRAM:
LSP SPRITE.H // LOADS THE SPRITE "H"
DSP 01 00 00 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 00
LSP SPRITE.E // LOADS THE SPRITE "E"
DSP 01 00 08 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 08
LSP SPRITE.L // LOADS THE SPRITE "L"
DSP 01 00 10 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 10
LSP SPRiTE.L // LOADS THE SPRITE "L"
DSP 01 00 18 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 18
LSP SPRITE.O // LOADS THE SPRITE "O"
DSP 01 00 20 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 20
LSP SPRITE.W // LOADS THE SPRITE "W"
DSP 01 00 30 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 30
LSP SPRITE.O // LOADS THE SPRITE "O"
DSP 01 00 38 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 38
LSP SPRITE.R // LOADS THE SPRITE "R"
DSP 01 00 40 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 40
LSP SPRITE.L // LOADS THE SPRITE "L"
DSP 01 00 48 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 48
LSP SPRITE.D // LOADS THE SPRITE "D"
DSP 01 00 50 // DRAWS THE SPRITE CURRENTLY LOADED AT DOUBLE THE NORMAL SIZE AT POSITION 00, 20




















WITHOUT THE COMMENTS AND WITH OPTIMIZATION, IT LOOKS LIKE THIS:
LSP SPRITE.H
DSP 01 00 00
LSP SPRITE.E
DSP 01 00 08
LSP SPRITE.L
DSP 01 00 10
DSP 01 00 18
DSP 00 00 48
LSP SPRITE.O
DSP 01 00 20
DSP 01 00 38
LSP SPRITE.W
DSP 01 00 30
LSP SPRITE.R
DSP 01 00 40
LSP SPRITE.D
DSP 01 00 50
AND AFTER REPLACING THE SPRITE NAMES WITH SPRITE IDS:
LSP b0011
DSP 01 00 00
LSP b000E
DSP 01 08 00
LSP b0015
DSP 01 10 00
DSP 01 18 00
DSP 01 48 00
LSP b0018
DSP 01 20 00
DSP 01 38 00
LSP b0020
DSP 01 30 00
LSP b001B
DSP 01 40 00
LSP b000D
DSP 01 50 00
LSP b0025
DSP 01 58 00
END


*NOTE: YOU DO HAVE TO USE THE NUMERIC SPRITE IDS ( ASK ME IF YOU NEED THEM )
THE PROGRAM WILL PRINT OUT "HELLO WORLD". YOU’VE WRITTEN YOUR FIRST PROGRAM!


CHAPTER 4: BRANCHING AND LOGIC
TO ADD STATEMENTS SUCH AS IF AND THEN, YOU NEED TO LEARN BRANCHING. BRANCHING IS USED TO JUMP TO OTHER SECTIONS OF THE CODE. THE STATEMENT IF ( TOMATO = 5 ) { TOMATO = 1 } IS WRITTEN IN 16BL ASM AS:
// TOMATO IS IN RAM SLOT 0000
LDA $0000
CMP 0005       // COMPARES THE ACCUMULATOR TO 0005
BNE @ELSE      // IF THE RESULT OF THE PREVIOUS CMP IS "NOT EQUAL", BRANCH TO @ELSE
LDA 0001
STA 0000       // STORE THE ACCUMULATOR TO ADDRESS 0000
@ELSE          // THIS IS @ELSE
A FULL TABLE OF OPCODES CAN BE FOUND AT THE BOTTOM OF THIS DOCUMENT






________________


NOTE: THE INSTRUCTION SET IS LOOSELY BASED ON 6502 ASSEMBLY

INSTRUCTION SET
FUNCTION NAME: END
ARGUMENTS: N/A
FLAGS: N/A
EFFECT: ENDS THE CURRENT SCRIPT (ENDS THE GAME IF THE CURRENT SCRIPT IS THE MAIN SCRIPT)


FUNCTION NAME: LDA
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: LOADS THE ACCUMULATOR TO 16.VALUE


FUNCTION NAME: STA
ARGUMENTS:
    16.ADDRESS
FLAGS:
    FLAG.RELATIVEX
EFFECT: STORES THE ACCUMULATOR TO 16.ADDRESS


FUNCTION NAME: LDX
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
EFFECT: LOADS THE X REGISTER TO 16.VALUE


FUNCTION NAME: STX
ARGUMENTS:
    16.ADDRESS
FLAGS:
   N/A
EFFECT: STORES THE X REGISTER TO 16.ADDRESS


FUNCTION NAME: CMP
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: COMPARES THE VALUE IN THE ACCUMULATOR TO 16.VALUE AND RETURNS THE RESULT TO SYS.BRANCHSTATE
FUNCTION NAME: BEQ
ARGUMENTS:
    16.POSITION
FLAGS:
    FLAG.RELATIVE ( ACTIVATES RELATIVE BRANCHING )
    FLAG.RELATIVEX
    FLAG.NEGATIVE
EFFECT: BRANCHES TO 16.POSITION IF SYS.BRANCHSTATE IS "EQUAL"


FUNCTION NAME: BNE
ARGUMENTS:
   16.POSITION
FLAGS:
   FLAG.RELATIVE ( ACTIVATES RELATIVE BRANCHING )
    FLAG.RELATIVEX
    FLAG.NEGATIVE
EFFECT: BRANCHES TO 16.POSITION IF SYS.BRANCHSTATE IS "NOT EQUAL"


FUNCTION NAME: BGT
ARGUMENTS:
    16.POSITION
FLAGS:
   FLAG.RELATIVE ( ACTIVATES RELATIVE BRANCHING )
   FLAG.RELATIVEX
    FLAG.NEGATIVE
EFFECT: BRANCHES TO 16.POSITION IF SYS.BRANCHSTATE IS "GREATER THAN"


FUNCTION NAME: BLT
ARGUMENTS:
    16.POSITION
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
    FLAG.NEGATIVE
EFFECT: BRANCHES TO 16.POSITION IF SYS.BRANCHSTATE IS "LESS THAN"

FUNCTION NAME: ADD
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: ADDS 16.VALUE TO THE ACCUMULATOR


FUNCTION NAME: SBC
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: SUBTRACTS 16.VALUE FROM THE ACCUMULATOR


FUNCTION NAME: MLT
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: MULTIPLIES 16.VALUE BY THE ACCUMULATOR


FUNCTION NAME: DIV
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: DIVIEDES 16.VALUE BY THE ACCUMULATOR


FUNCTION NAME: MOD
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: FINDS THE MOD OF 16.VALUE AND THE ACCUMULATOR


FUNCTION NAME: AND
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAGS.RELATIVEX
EFFECT: PERFORMS A BITWISE AND ON THE ACCUMULATOR WITH 16.VALUE


FUNCTION NAME: IOR
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: PERFORMS A BITWISE INCLUSIVE OR ON THE ACCUMULATOR WITH 16.VALUE


FUNCTION NAME: XOR
ARGUMENTS:
    16.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: PERFORMS A BITWISE EXCLUSIVE OR ON THE ACCUMULATOR WITH 16.VALUE


FUNCTION NAME: BSL
ARGUMENTS:
    8.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: PERFORMS A BIT SHIfT LEFT ON THE ACCUMULATOR BY 8.VALUE BITS


FUNCTION NAME: BSR
ARGUMENTS:
    8.VALUE
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: PERFORMS A BIT SHIFT RIGHT ON THE ACCUMULATOR 8.VALUE BITS


FUNCTION NAME: LSP
ARGUMENTS:
    16.SPRITE_ID
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
    FLAG.BINARYSPRITE
EFFECT: LOADS THE SPRITE 16.SPRITE_ID INTO MEMORY


FUNCTION NAME: DSP
ARGUMENTS:
    8.SPRITEDATA ( 2.SPRITE_TYPE, 6.SPRITE_SIZE )
    8.XPOS
    8.YPOS
FLAGS:
    FLAG.RELATIVE ( APPLIES TO 8.XPOS AND 8.YPOS )
    FLAG.RELATIVEX ( APPLIES TO 8.SPRITEDATA )
EFFECT: DRAWS THE CURRENTLY LOADED SPRITE WITH 8.SPRITEDATA AT POSITION 8.XPOS, 8.YPOS
FUNCTION NAME: MPL
ARGUMENTS:
    4.POSITION
    8.BYTE ( 1 )
    8.BYTE ( 2 )
    8.BYTE ( 3 )
    4.BLEND
FLAGS:
    FLAG.RELATIVE ( APPLIES TO 8.BYTE ( 1 ), 8.BYTE ( 2 ), 8.BYTE ( 3 ), AND 4.BLEND )
   FLAG.RELATIVEX ( APPLIES TO 8.POSITION )
EFFECT: CHANGES THE MASTER PALETTE, INSERTING ALL 3 BYTE ARGUMENTS IN ORDER AT 4.POSITION WITH BLEND SATURATION 4.BLEND














FUNCTION NAME: KEY
ARGUMENTS:
     8.KEY_ID
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: WRITES 1 TO THE ACCUMULATOR IF KEY 8.KEY_ID IS PRESSED


FUNCTION NAME: JMP
ARGUMENTS:
    16.POSITION
FLAGS:
   FLAG.RELATIVE
    FLAG.RELATIVEX
    FLAG.NEGATIVE
EFFECT: BRANCHES TO 16.POSITION


FUNCTION NAME: FLR
ARGUMENTS:
    16.FILEID
    16.LOCATION
    16.AMOUNT
    16.ADDRESS
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: LOADS 16.BYTES BYTES OF THE FILE WITH ID 16.FILEID STARTING AT 16.LOCATION TO RAM SLOT 16.ADDRESS


FUNCTION NAME: FLW
ARGUMENTS:
    16.FILEID
    16.ADDRESS
    16.AMOUNT
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: STORES 16.BYTES BYTES OF RAM STARTING AT 16.ADDRESS TO THE FILE 16.FILEID












FUNCTION NAME: EXE
ARGUMENTS:
    16.ADDRESS
FLAGS:
    FLAG.RELATIVE
    FLAG.RELATIVEX
EFFECT: EXECUTES CODE FROM RAM POSITION 16.ADDRESS


FUNCTION NAME: TAX
ARGUMENTS: N/A
FLAGS: N/A
EFFECT: COPIES THE VALUE IN THE X REGISTER TO THE ACCUMULATOR


FUNCTION NAME: TXA
ARGUMENTS: N/A
FLAGS: N/A
EFFECT: COPIES THE VALUE IN THE ACCUMULATOR TO THE X REGISTER


FUNCTION NAME: PSD
ARGUMENTS:
    16.FILEID
FLAGS:
    RELATIVE
   RELATIVEX
EFFECT: PLAYS THE SOUND 16.FILEID


FUNCTION NAME: RPC
ARGUMENTS: N/A
FLAGS: N/A
EFFECT: COPIES THE PROGRAM COUNTER TO THE ACCUMULATOR